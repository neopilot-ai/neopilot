// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v5.27.3
// source: contract.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientDuplexStream,
  type ClientOptions,
  type ClientUnaryCall,
  type handleBidiStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Struct } from "./google/protobuf/struct";

export const protobufPackage = "";

export interface ClientEvent {
  startRequest?: StartWorkflowRequest | undefined;
  actionResponse?: ActionResponse | undefined;
  heartbeat?: HeartbeatRequest | undefined;
  stopWorkflow?: StopWorkflowRequest | undefined;
}

export interface StartWorkflowRequest {
  clientVersion: string;
  workflowID: string;
  workflowDefinition: string;
  goal: string;
  workflowMetadata: string;
  clientCapabilities: string[];
  mcpTools: McpTool[];
  additionalContext: AdditionalContext[];
  approval?: Approval | undefined;
  flowConfig?: { [key: string]: any } | undefined;
  flowConfigSchemaVersion?: string | undefined;
  preapprovedTools: string[];
}

export interface ActionResponse {
  requestID: string;
  response?: string | undefined;
  plainTextResponse?: PlainTextResponse | undefined;
  httpResponse?: HttpResponse | undefined;
}

export interface HeartbeatRequest {
  timestamp: number;
}

export interface StopWorkflowRequest {
  reason: string;
}

export interface PlainTextResponse {
  response: string;
  error: string;
}

export interface HttpResponse {
  headers: { [key: string]: string };
  statusCode: number;
  body: string;
  error: string;
}

export interface HttpResponse_HeadersEntry {
  key: string;
  value: string;
}

export interface Action {
  requestID: string;
  runCommand?: RunCommandAction | undefined;
  runHTTPRequest?: RunHTTPRequest | undefined;
  runReadFile?: ReadFile | undefined;
  runWriteFile?: WriteFile | undefined;
  runGitCommand?: RunGitCommand | undefined;
  runEditFile?: EditFile | undefined;
  newCheckpoint?: NewCheckpoint | undefined;
  listDirectory?: ListDirectory | undefined;
  grep?: Grep | undefined;
  findFiles?: FindFiles | undefined;
  runMCPTool?: RunMCPTool | undefined;
  mkdir?: Mkdir | undefined;
  runReadFiles?: ReadFiles | undefined;
}

export interface RunCommandAction {
  program: string;
  arguments: string[];
  flags: string[];
}

export interface ReadFile {
  filepath: string;
  limit?: number | undefined;
  offset?: number | undefined;
}

export interface ReadFiles {
  filepaths: string[];
}

export interface WriteFile {
  filepath: string;
  contents: string;
}

export interface EditFile {
  filepath: string;
  oldString: string;
  newString: string;
}

export interface RunHTTPRequest {
  method: string;
  path: string;
  body?: string | undefined;
}

export interface RunGitCommand {
  command: string;
  arguments?: string | undefined;
  repositoryUrl: string;
}

export interface GenerateTokenRequest {
  workflowDefinition?: string | undefined;
}

export interface GenerateTokenResponse {
  token: string;
  expiresAt: number;
}

/** Intentionally empty */
export interface ListToolsRequest {
}

export interface ListToolsResponse {
  tools: { [key: string]: any }[];
  evalDataset: { [key: string]: any }[];
}

export interface ListFlowsRequest {
  filters?: ListFlowsRequestFilter | undefined;
}

export interface ListFlowsRequestFilter {
  flowIdentifier: string[];
  environment: string[];
  version: string[];
}

export interface ListFlowsResponse {
  configs: { [key: string]: any }[];
}

export interface NewCheckpoint {
  status: string;
  checkpoint: string;
  goal: string;
  errors: string[];
}

export interface ListDirectory {
  directory: string;
}

export interface Grep {
  searchDirectory: string;
  pattern: string;
  caseInsensitive: boolean;
}

export interface FindFiles {
  namePattern: string;
}

export interface McpTool {
  name: string;
  description: string;
  inputSchema: string;
}

export interface RunMCPTool {
  name: string;
  args: string;
}

export interface AdditionalContext {
  category: string;
  id?: string | undefined;
  content?: string | undefined;
  metadata?: string | undefined;
}

export interface Approval {
  approval?: Approval_Approved | undefined;
  rejection?: Approval_Rejected | undefined;
}

export interface Approval_Approved {
}

export interface Approval_Rejected {
  message?: string | undefined;
}

export interface Mkdir {
  directoryPath: string;
}

export interface OsInformationContext {
  platform: string;
  architecture: string;
}

export interface ShellInformationContext {
  shellName: string;
  shellType: string;
  shellVariant?: string | undefined;
  shellEnvironment?: string | undefined;
  sshSession?: boolean | undefined;
  cwd?: string | undefined;
}

function createBaseClientEvent(): ClientEvent {
  return { startRequest: undefined, actionResponse: undefined, heartbeat: undefined, stopWorkflow: undefined };
}

export const ClientEvent: MessageFns<ClientEvent> = {
  encode(message: ClientEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startRequest !== undefined) {
      StartWorkflowRequest.encode(message.startRequest, writer.uint32(10).fork()).join();
    }
    if (message.actionResponse !== undefined) {
      ActionResponse.encode(message.actionResponse, writer.uint32(18).fork()).join();
    }
    if (message.heartbeat !== undefined) {
      HeartbeatRequest.encode(message.heartbeat, writer.uint32(26).fork()).join();
    }
    if (message.stopWorkflow !== undefined) {
      StopWorkflowRequest.encode(message.stopWorkflow, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.startRequest = StartWorkflowRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.actionResponse = ActionResponse.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.heartbeat = HeartbeatRequest.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.stopWorkflow = StopWorkflowRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientEvent {
    return {
      startRequest: isSet(object.startRequest) ? StartWorkflowRequest.fromJSON(object.startRequest) : undefined,
      actionResponse: isSet(object.actionResponse) ? ActionResponse.fromJSON(object.actionResponse) : undefined,
      heartbeat: isSet(object.heartbeat) ? HeartbeatRequest.fromJSON(object.heartbeat) : undefined,
      stopWorkflow: isSet(object.stopWorkflow) ? StopWorkflowRequest.fromJSON(object.stopWorkflow) : undefined,
    };
  },

  toJSON(message: ClientEvent): unknown {
    const obj: any = {};
    if (message.startRequest !== undefined) {
      obj.startRequest = StartWorkflowRequest.toJSON(message.startRequest);
    }
    if (message.actionResponse !== undefined) {
      obj.actionResponse = ActionResponse.toJSON(message.actionResponse);
    }
    if (message.heartbeat !== undefined) {
      obj.heartbeat = HeartbeatRequest.toJSON(message.heartbeat);
    }
    if (message.stopWorkflow !== undefined) {
      obj.stopWorkflow = StopWorkflowRequest.toJSON(message.stopWorkflow);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientEvent>, I>>(base?: I): ClientEvent {
    return ClientEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientEvent>, I>>(object: I): ClientEvent {
    const message = createBaseClientEvent();
    message.startRequest = (object.startRequest !== undefined && object.startRequest !== null)
      ? StartWorkflowRequest.fromPartial(object.startRequest)
      : undefined;
    message.actionResponse = (object.actionResponse !== undefined && object.actionResponse !== null)
      ? ActionResponse.fromPartial(object.actionResponse)
      : undefined;
    message.heartbeat = (object.heartbeat !== undefined && object.heartbeat !== null)
      ? HeartbeatRequest.fromPartial(object.heartbeat)
      : undefined;
    message.stopWorkflow = (object.stopWorkflow !== undefined && object.stopWorkflow !== null)
      ? StopWorkflowRequest.fromPartial(object.stopWorkflow)
      : undefined;
    return message;
  },
};

function createBaseStartWorkflowRequest(): StartWorkflowRequest {
  return {
    clientVersion: "",
    workflowID: "",
    workflowDefinition: "",
    goal: "",
    workflowMetadata: "",
    clientCapabilities: [],
    mcpTools: [],
    additionalContext: [],
    approval: undefined,
    flowConfig: undefined,
    flowConfigSchemaVersion: undefined,
    preapprovedTools: [],
  };
}

export const StartWorkflowRequest: MessageFns<StartWorkflowRequest> = {
  encode(message: StartWorkflowRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientVersion !== "") {
      writer.uint32(10).string(message.clientVersion);
    }
    if (message.workflowID !== "") {
      writer.uint32(18).string(message.workflowID);
    }
    if (message.workflowDefinition !== "") {
      writer.uint32(26).string(message.workflowDefinition);
    }
    if (message.goal !== "") {
      writer.uint32(34).string(message.goal);
    }
    if (message.workflowMetadata !== "") {
      writer.uint32(42).string(message.workflowMetadata);
    }
    for (const v of message.clientCapabilities) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.mcpTools) {
      McpTool.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.additionalContext) {
      AdditionalContext.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.approval !== undefined) {
      Approval.encode(message.approval, writer.uint32(82).fork()).join();
    }
    if (message.flowConfig !== undefined) {
      Struct.encode(Struct.wrap(message.flowConfig), writer.uint32(90).fork()).join();
    }
    if (message.flowConfigSchemaVersion !== undefined) {
      writer.uint32(98).string(message.flowConfigSchemaVersion);
    }
    for (const v of message.preapprovedTools) {
      writer.uint32(106).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartWorkflowRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartWorkflowRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientVersion = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflowID = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.workflowDefinition = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.goal = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.workflowMetadata = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.clientCapabilities.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.mcpTools.push(McpTool.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.additionalContext.push(AdditionalContext.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.approval = Approval.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.flowConfig = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.flowConfigSchemaVersion = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.preapprovedTools.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartWorkflowRequest {
    return {
      clientVersion: isSet(object.clientVersion) ? globalThis.String(object.clientVersion) : "",
      workflowID: isSet(object.workflowID) ? globalThis.String(object.workflowID) : "",
      workflowDefinition: isSet(object.workflowDefinition) ? globalThis.String(object.workflowDefinition) : "",
      goal: isSet(object.goal) ? globalThis.String(object.goal) : "",
      workflowMetadata: isSet(object.workflowMetadata) ? globalThis.String(object.workflowMetadata) : "",
      clientCapabilities: globalThis.Array.isArray(object?.clientCapabilities)
        ? object.clientCapabilities.map((e: any) => globalThis.String(e))
        : [],
      mcpTools: globalThis.Array.isArray(object?.mcpTools) ? object.mcpTools.map((e: any) => McpTool.fromJSON(e)) : [],
      additionalContext: globalThis.Array.isArray(object?.additionalContext)
        ? object.additionalContext.map((e: any) => AdditionalContext.fromJSON(e))
        : [],
      approval: isSet(object.approval) ? Approval.fromJSON(object.approval) : undefined,
      flowConfig: isObject(object.flowConfig) ? object.flowConfig : undefined,
      flowConfigSchemaVersion: isSet(object.flowConfigSchemaVersion)
        ? globalThis.String(object.flowConfigSchemaVersion)
        : undefined,
      preapprovedTools: globalThis.Array.isArray(object?.preapprovedTools)
        ? object.preapprovedTools.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: StartWorkflowRequest): unknown {
    const obj: any = {};
    if (message.clientVersion !== "") {
      obj.clientVersion = message.clientVersion;
    }
    if (message.workflowID !== "") {
      obj.workflowID = message.workflowID;
    }
    if (message.workflowDefinition !== "") {
      obj.workflowDefinition = message.workflowDefinition;
    }
    if (message.goal !== "") {
      obj.goal = message.goal;
    }
    if (message.workflowMetadata !== "") {
      obj.workflowMetadata = message.workflowMetadata;
    }
    if (message.clientCapabilities?.length) {
      obj.clientCapabilities = message.clientCapabilities;
    }
    if (message.mcpTools?.length) {
      obj.mcpTools = message.mcpTools.map((e) => McpTool.toJSON(e));
    }
    if (message.additionalContext?.length) {
      obj.additionalContext = message.additionalContext.map((e) => AdditionalContext.toJSON(e));
    }
    if (message.approval !== undefined) {
      obj.approval = Approval.toJSON(message.approval);
    }
    if (message.flowConfig !== undefined) {
      obj.flowConfig = message.flowConfig;
    }
    if (message.flowConfigSchemaVersion !== undefined) {
      obj.flowConfigSchemaVersion = message.flowConfigSchemaVersion;
    }
    if (message.preapprovedTools?.length) {
      obj.preapprovedTools = message.preapprovedTools;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StartWorkflowRequest>, I>>(base?: I): StartWorkflowRequest {
    return StartWorkflowRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StartWorkflowRequest>, I>>(object: I): StartWorkflowRequest {
    const message = createBaseStartWorkflowRequest();
    message.clientVersion = object.clientVersion ?? "";
    message.workflowID = object.workflowID ?? "";
    message.workflowDefinition = object.workflowDefinition ?? "";
    message.goal = object.goal ?? "";
    message.workflowMetadata = object.workflowMetadata ?? "";
    message.clientCapabilities = object.clientCapabilities?.map((e) => e) || [];
    message.mcpTools = object.mcpTools?.map((e) => McpTool.fromPartial(e)) || [];
    message.additionalContext = object.additionalContext?.map((e) => AdditionalContext.fromPartial(e)) || [];
    message.approval = (object.approval !== undefined && object.approval !== null)
      ? Approval.fromPartial(object.approval)
      : undefined;
    message.flowConfig = object.flowConfig ?? undefined;
    message.flowConfigSchemaVersion = object.flowConfigSchemaVersion ?? undefined;
    message.preapprovedTools = object.preapprovedTools?.map((e) => e) || [];
    return message;
  },
};

function createBaseActionResponse(): ActionResponse {
  return { requestID: "", response: undefined, plainTextResponse: undefined, httpResponse: undefined };
}

export const ActionResponse: MessageFns<ActionResponse> = {
  encode(message: ActionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestID !== "") {
      writer.uint32(10).string(message.requestID);
    }
    if (message.response !== undefined) {
      writer.uint32(18).string(message.response);
    }
    if (message.plainTextResponse !== undefined) {
      PlainTextResponse.encode(message.plainTextResponse, writer.uint32(26).fork()).join();
    }
    if (message.httpResponse !== undefined) {
      HttpResponse.encode(message.httpResponse, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.response = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.plainTextResponse = PlainTextResponse.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.httpResponse = HttpResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActionResponse {
    return {
      requestID: isSet(object.requestID) ? globalThis.String(object.requestID) : "",
      response: isSet(object.response) ? globalThis.String(object.response) : undefined,
      plainTextResponse: isSet(object.plainTextResponse)
        ? PlainTextResponse.fromJSON(object.plainTextResponse)
        : undefined,
      httpResponse: isSet(object.httpResponse) ? HttpResponse.fromJSON(object.httpResponse) : undefined,
    };
  },

  toJSON(message: ActionResponse): unknown {
    const obj: any = {};
    if (message.requestID !== "") {
      obj.requestID = message.requestID;
    }
    if (message.response !== undefined) {
      obj.response = message.response;
    }
    if (message.plainTextResponse !== undefined) {
      obj.plainTextResponse = PlainTextResponse.toJSON(message.plainTextResponse);
    }
    if (message.httpResponse !== undefined) {
      obj.httpResponse = HttpResponse.toJSON(message.httpResponse);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ActionResponse>, I>>(base?: I): ActionResponse {
    return ActionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ActionResponse>, I>>(object: I): ActionResponse {
    const message = createBaseActionResponse();
    message.requestID = object.requestID ?? "";
    message.response = object.response ?? undefined;
    message.plainTextResponse = (object.plainTextResponse !== undefined && object.plainTextResponse !== null)
      ? PlainTextResponse.fromPartial(object.plainTextResponse)
      : undefined;
    message.httpResponse = (object.httpResponse !== undefined && object.httpResponse !== null)
      ? HttpResponse.fromPartial(object.httpResponse)
      : undefined;
    return message;
  },
};

function createBaseHeartbeatRequest(): HeartbeatRequest {
  return { timestamp: 0 };
}

export const HeartbeatRequest: MessageFns<HeartbeatRequest> = {
  encode(message: HeartbeatRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== 0) {
      writer.uint32(8).int64(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeartbeatRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartbeatRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.timestamp = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeartbeatRequest {
    return { timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0 };
  },

  toJSON(message: HeartbeatRequest): unknown {
    const obj: any = {};
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HeartbeatRequest>, I>>(base?: I): HeartbeatRequest {
    return HeartbeatRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeartbeatRequest>, I>>(object: I): HeartbeatRequest {
    const message = createBaseHeartbeatRequest();
    message.timestamp = object.timestamp ?? 0;
    return message;
  },
};

function createBaseStopWorkflowRequest(): StopWorkflowRequest {
  return { reason: "" };
}

export const StopWorkflowRequest: MessageFns<StopWorkflowRequest> = {
  encode(message: StopWorkflowRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reason !== "") {
      writer.uint32(10).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StopWorkflowRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStopWorkflowRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StopWorkflowRequest {
    return { reason: isSet(object.reason) ? globalThis.String(object.reason) : "" };
  },

  toJSON(message: StopWorkflowRequest): unknown {
    const obj: any = {};
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StopWorkflowRequest>, I>>(base?: I): StopWorkflowRequest {
    return StopWorkflowRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StopWorkflowRequest>, I>>(object: I): StopWorkflowRequest {
    const message = createBaseStopWorkflowRequest();
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBasePlainTextResponse(): PlainTextResponse {
  return { response: "", error: "" };
}

export const PlainTextResponse: MessageFns<PlainTextResponse> = {
  encode(message: PlainTextResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.response !== "") {
      writer.uint32(10).string(message.response);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlainTextResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlainTextResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.response = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlainTextResponse {
    return {
      response: isSet(object.response) ? globalThis.String(object.response) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: PlainTextResponse): unknown {
    const obj: any = {};
    if (message.response !== "") {
      obj.response = message.response;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlainTextResponse>, I>>(base?: I): PlainTextResponse {
    return PlainTextResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlainTextResponse>, I>>(object: I): PlainTextResponse {
    const message = createBasePlainTextResponse();
    message.response = object.response ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseHttpResponse(): HttpResponse {
  return { headers: {}, statusCode: 0, body: "", error: "" };
}

export const HttpResponse: MessageFns<HttpResponse> = {
  encode(message: HttpResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.headers).forEach(([key, value]) => {
      HttpResponse_HeadersEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    if (message.statusCode !== 0) {
      writer.uint32(16).int32(message.statusCode);
    }
    if (message.body !== "") {
      writer.uint32(26).string(message.body);
    }
    if (message.error !== "") {
      writer.uint32(34).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = HttpResponse_HeadersEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.headers[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.statusCode = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.body = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpResponse {
    return {
      headers: isObject(object.headers)
        ? Object.entries(object.headers).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      statusCode: isSet(object.statusCode) ? globalThis.Number(object.statusCode) : 0,
      body: isSet(object.body) ? globalThis.String(object.body) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: HttpResponse): unknown {
    const obj: any = {};
    if (message.headers) {
      const entries = Object.entries(message.headers);
      if (entries.length > 0) {
        obj.headers = {};
        entries.forEach(([k, v]) => {
          obj.headers[k] = v;
        });
      }
    }
    if (message.statusCode !== 0) {
      obj.statusCode = Math.round(message.statusCode);
    }
    if (message.body !== "") {
      obj.body = message.body;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpResponse>, I>>(base?: I): HttpResponse {
    return HttpResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpResponse>, I>>(object: I): HttpResponse {
    const message = createBaseHttpResponse();
    message.headers = Object.entries(object.headers ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.statusCode = object.statusCode ?? 0;
    message.body = object.body ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseHttpResponse_HeadersEntry(): HttpResponse_HeadersEntry {
  return { key: "", value: "" };
}

export const HttpResponse_HeadersEntry: MessageFns<HttpResponse_HeadersEntry> = {
  encode(message: HttpResponse_HeadersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpResponse_HeadersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpResponse_HeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpResponse_HeadersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: HttpResponse_HeadersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpResponse_HeadersEntry>, I>>(base?: I): HttpResponse_HeadersEntry {
    return HttpResponse_HeadersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpResponse_HeadersEntry>, I>>(object: I): HttpResponse_HeadersEntry {
    const message = createBaseHttpResponse_HeadersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAction(): Action {
  return {
    requestID: "",
    runCommand: undefined,
    runHTTPRequest: undefined,
    runReadFile: undefined,
    runWriteFile: undefined,
    runGitCommand: undefined,
    runEditFile: undefined,
    newCheckpoint: undefined,
    listDirectory: undefined,
    grep: undefined,
    findFiles: undefined,
    runMCPTool: undefined,
    mkdir: undefined,
    runReadFiles: undefined,
  };
}

export const Action: MessageFns<Action> = {
  encode(message: Action, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestID !== "") {
      writer.uint32(10).string(message.requestID);
    }
    if (message.runCommand !== undefined) {
      RunCommandAction.encode(message.runCommand, writer.uint32(18).fork()).join();
    }
    if (message.runHTTPRequest !== undefined) {
      RunHTTPRequest.encode(message.runHTTPRequest, writer.uint32(26).fork()).join();
    }
    if (message.runReadFile !== undefined) {
      ReadFile.encode(message.runReadFile, writer.uint32(34).fork()).join();
    }
    if (message.runWriteFile !== undefined) {
      WriteFile.encode(message.runWriteFile, writer.uint32(42).fork()).join();
    }
    if (message.runGitCommand !== undefined) {
      RunGitCommand.encode(message.runGitCommand, writer.uint32(50).fork()).join();
    }
    if (message.runEditFile !== undefined) {
      EditFile.encode(message.runEditFile, writer.uint32(58).fork()).join();
    }
    if (message.newCheckpoint !== undefined) {
      NewCheckpoint.encode(message.newCheckpoint, writer.uint32(66).fork()).join();
    }
    if (message.listDirectory !== undefined) {
      ListDirectory.encode(message.listDirectory, writer.uint32(74).fork()).join();
    }
    if (message.grep !== undefined) {
      Grep.encode(message.grep, writer.uint32(82).fork()).join();
    }
    if (message.findFiles !== undefined) {
      FindFiles.encode(message.findFiles, writer.uint32(90).fork()).join();
    }
    if (message.runMCPTool !== undefined) {
      RunMCPTool.encode(message.runMCPTool, writer.uint32(98).fork()).join();
    }
    if (message.mkdir !== undefined) {
      Mkdir.encode(message.mkdir, writer.uint32(106).fork()).join();
    }
    if (message.runReadFiles !== undefined) {
      ReadFiles.encode(message.runReadFiles, writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Action {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.runCommand = RunCommandAction.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.runHTTPRequest = RunHTTPRequest.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.runReadFile = ReadFile.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.runWriteFile = WriteFile.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.runGitCommand = RunGitCommand.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.runEditFile = EditFile.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.newCheckpoint = NewCheckpoint.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.listDirectory = ListDirectory.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.grep = Grep.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.findFiles = FindFiles.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.runMCPTool = RunMCPTool.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.mkdir = Mkdir.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.runReadFiles = ReadFiles.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Action {
    return {
      requestID: isSet(object.requestID) ? globalThis.String(object.requestID) : "",
      runCommand: isSet(object.runCommand) ? RunCommandAction.fromJSON(object.runCommand) : undefined,
      runHTTPRequest: isSet(object.runHTTPRequest) ? RunHTTPRequest.fromJSON(object.runHTTPRequest) : undefined,
      runReadFile: isSet(object.runReadFile) ? ReadFile.fromJSON(object.runReadFile) : undefined,
      runWriteFile: isSet(object.runWriteFile) ? WriteFile.fromJSON(object.runWriteFile) : undefined,
      runGitCommand: isSet(object.runGitCommand) ? RunGitCommand.fromJSON(object.runGitCommand) : undefined,
      runEditFile: isSet(object.runEditFile) ? EditFile.fromJSON(object.runEditFile) : undefined,
      newCheckpoint: isSet(object.newCheckpoint) ? NewCheckpoint.fromJSON(object.newCheckpoint) : undefined,
      listDirectory: isSet(object.listDirectory) ? ListDirectory.fromJSON(object.listDirectory) : undefined,
      grep: isSet(object.grep) ? Grep.fromJSON(object.grep) : undefined,
      findFiles: isSet(object.findFiles) ? FindFiles.fromJSON(object.findFiles) : undefined,
      runMCPTool: isSet(object.runMCPTool) ? RunMCPTool.fromJSON(object.runMCPTool) : undefined,
      mkdir: isSet(object.mkdir) ? Mkdir.fromJSON(object.mkdir) : undefined,
      runReadFiles: isSet(object.runReadFiles) ? ReadFiles.fromJSON(object.runReadFiles) : undefined,
    };
  },

  toJSON(message: Action): unknown {
    const obj: any = {};
    if (message.requestID !== "") {
      obj.requestID = message.requestID;
    }
    if (message.runCommand !== undefined) {
      obj.runCommand = RunCommandAction.toJSON(message.runCommand);
    }
    if (message.runHTTPRequest !== undefined) {
      obj.runHTTPRequest = RunHTTPRequest.toJSON(message.runHTTPRequest);
    }
    if (message.runReadFile !== undefined) {
      obj.runReadFile = ReadFile.toJSON(message.runReadFile);
    }
    if (message.runWriteFile !== undefined) {
      obj.runWriteFile = WriteFile.toJSON(message.runWriteFile);
    }
    if (message.runGitCommand !== undefined) {
      obj.runGitCommand = RunGitCommand.toJSON(message.runGitCommand);
    }
    if (message.runEditFile !== undefined) {
      obj.runEditFile = EditFile.toJSON(message.runEditFile);
    }
    if (message.newCheckpoint !== undefined) {
      obj.newCheckpoint = NewCheckpoint.toJSON(message.newCheckpoint);
    }
    if (message.listDirectory !== undefined) {
      obj.listDirectory = ListDirectory.toJSON(message.listDirectory);
    }
    if (message.grep !== undefined) {
      obj.grep = Grep.toJSON(message.grep);
    }
    if (message.findFiles !== undefined) {
      obj.findFiles = FindFiles.toJSON(message.findFiles);
    }
    if (message.runMCPTool !== undefined) {
      obj.runMCPTool = RunMCPTool.toJSON(message.runMCPTool);
    }
    if (message.mkdir !== undefined) {
      obj.mkdir = Mkdir.toJSON(message.mkdir);
    }
    if (message.runReadFiles !== undefined) {
      obj.runReadFiles = ReadFiles.toJSON(message.runReadFiles);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Action>, I>>(base?: I): Action {
    return Action.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Action>, I>>(object: I): Action {
    const message = createBaseAction();
    message.requestID = object.requestID ?? "";
    message.runCommand = (object.runCommand !== undefined && object.runCommand !== null)
      ? RunCommandAction.fromPartial(object.runCommand)
      : undefined;
    message.runHTTPRequest = (object.runHTTPRequest !== undefined && object.runHTTPRequest !== null)
      ? RunHTTPRequest.fromPartial(object.runHTTPRequest)
      : undefined;
    message.runReadFile = (object.runReadFile !== undefined && object.runReadFile !== null)
      ? ReadFile.fromPartial(object.runReadFile)
      : undefined;
    message.runWriteFile = (object.runWriteFile !== undefined && object.runWriteFile !== null)
      ? WriteFile.fromPartial(object.runWriteFile)
      : undefined;
    message.runGitCommand = (object.runGitCommand !== undefined && object.runGitCommand !== null)
      ? RunGitCommand.fromPartial(object.runGitCommand)
      : undefined;
    message.runEditFile = (object.runEditFile !== undefined && object.runEditFile !== null)
      ? EditFile.fromPartial(object.runEditFile)
      : undefined;
    message.newCheckpoint = (object.newCheckpoint !== undefined && object.newCheckpoint !== null)
      ? NewCheckpoint.fromPartial(object.newCheckpoint)
      : undefined;
    message.listDirectory = (object.listDirectory !== undefined && object.listDirectory !== null)
      ? ListDirectory.fromPartial(object.listDirectory)
      : undefined;
    message.grep = (object.grep !== undefined && object.grep !== null) ? Grep.fromPartial(object.grep) : undefined;
    message.findFiles = (object.findFiles !== undefined && object.findFiles !== null)
      ? FindFiles.fromPartial(object.findFiles)
      : undefined;
    message.runMCPTool = (object.runMCPTool !== undefined && object.runMCPTool !== null)
      ? RunMCPTool.fromPartial(object.runMCPTool)
      : undefined;
    message.mkdir = (object.mkdir !== undefined && object.mkdir !== null) ? Mkdir.fromPartial(object.mkdir) : undefined;
    message.runReadFiles = (object.runReadFiles !== undefined && object.runReadFiles !== null)
      ? ReadFiles.fromPartial(object.runReadFiles)
      : undefined;
    return message;
  },
};

function createBaseRunCommandAction(): RunCommandAction {
  return { program: "", arguments: [], flags: [] };
}

export const RunCommandAction: MessageFns<RunCommandAction> = {
  encode(message: RunCommandAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.program !== "") {
      writer.uint32(26).string(message.program);
    }
    for (const v of message.arguments) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.flags) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunCommandAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunCommandAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.program = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.arguments.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.flags.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunCommandAction {
    return {
      program: isSet(object.program) ? globalThis.String(object.program) : "",
      arguments: globalThis.Array.isArray(object?.arguments)
        ? object.arguments.map((e: any) => globalThis.String(e))
        : [],
      flags: globalThis.Array.isArray(object?.flags) ? object.flags.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: RunCommandAction): unknown {
    const obj: any = {};
    if (message.program !== "") {
      obj.program = message.program;
    }
    if (message.arguments?.length) {
      obj.arguments = message.arguments;
    }
    if (message.flags?.length) {
      obj.flags = message.flags;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunCommandAction>, I>>(base?: I): RunCommandAction {
    return RunCommandAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunCommandAction>, I>>(object: I): RunCommandAction {
    const message = createBaseRunCommandAction();
    message.program = object.program ?? "";
    message.arguments = object.arguments?.map((e) => e) || [];
    message.flags = object.flags?.map((e) => e) || [];
    return message;
  },
};

function createBaseReadFile(): ReadFile {
  return { filepath: "", limit: undefined, offset: undefined };
}

export const ReadFile: MessageFns<ReadFile> = {
  encode(message: ReadFile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filepath !== "") {
      writer.uint32(10).string(message.filepath);
    }
    if (message.limit !== undefined) {
      writer.uint32(16).int64(message.limit);
    }
    if (message.offset !== undefined) {
      writer.uint32(24).int64(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadFile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filepath = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.offset = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadFile {
    return {
      filepath: isSet(object.filepath) ? globalThis.String(object.filepath) : "",
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : undefined,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : undefined,
    };
  },

  toJSON(message: ReadFile): unknown {
    const obj: any = {};
    if (message.filepath !== "") {
      obj.filepath = message.filepath;
    }
    if (message.limit !== undefined) {
      obj.limit = Math.round(message.limit);
    }
    if (message.offset !== undefined) {
      obj.offset = Math.round(message.offset);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReadFile>, I>>(base?: I): ReadFile {
    return ReadFile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReadFile>, I>>(object: I): ReadFile {
    const message = createBaseReadFile();
    message.filepath = object.filepath ?? "";
    message.limit = object.limit ?? undefined;
    message.offset = object.offset ?? undefined;
    return message;
  },
};

function createBaseReadFiles(): ReadFiles {
  return { filepaths: [] };
}

export const ReadFiles: MessageFns<ReadFiles> = {
  encode(message: ReadFiles, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.filepaths) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadFiles {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadFiles();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filepaths.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadFiles {
    return {
      filepaths: globalThis.Array.isArray(object?.filepaths)
        ? object.filepaths.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ReadFiles): unknown {
    const obj: any = {};
    if (message.filepaths?.length) {
      obj.filepaths = message.filepaths;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReadFiles>, I>>(base?: I): ReadFiles {
    return ReadFiles.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReadFiles>, I>>(object: I): ReadFiles {
    const message = createBaseReadFiles();
    message.filepaths = object.filepaths?.map((e) => e) || [];
    return message;
  },
};

function createBaseWriteFile(): WriteFile {
  return { filepath: "", contents: "" };
}

export const WriteFile: MessageFns<WriteFile> = {
  encode(message: WriteFile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filepath !== "") {
      writer.uint32(10).string(message.filepath);
    }
    if (message.contents !== "") {
      writer.uint32(18).string(message.contents);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WriteFile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWriteFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filepath = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contents = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WriteFile {
    return {
      filepath: isSet(object.filepath) ? globalThis.String(object.filepath) : "",
      contents: isSet(object.contents) ? globalThis.String(object.contents) : "",
    };
  },

  toJSON(message: WriteFile): unknown {
    const obj: any = {};
    if (message.filepath !== "") {
      obj.filepath = message.filepath;
    }
    if (message.contents !== "") {
      obj.contents = message.contents;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WriteFile>, I>>(base?: I): WriteFile {
    return WriteFile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WriteFile>, I>>(object: I): WriteFile {
    const message = createBaseWriteFile();
    message.filepath = object.filepath ?? "";
    message.contents = object.contents ?? "";
    return message;
  },
};

function createBaseEditFile(): EditFile {
  return { filepath: "", oldString: "", newString: "" };
}

export const EditFile: MessageFns<EditFile> = {
  encode(message: EditFile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filepath !== "") {
      writer.uint32(10).string(message.filepath);
    }
    if (message.oldString !== "") {
      writer.uint32(18).string(message.oldString);
    }
    if (message.newString !== "") {
      writer.uint32(26).string(message.newString);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EditFile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEditFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filepath = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.oldString = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newString = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EditFile {
    return {
      filepath: isSet(object.filepath) ? globalThis.String(object.filepath) : "",
      oldString: isSet(object.oldString) ? globalThis.String(object.oldString) : "",
      newString: isSet(object.newString) ? globalThis.String(object.newString) : "",
    };
  },

  toJSON(message: EditFile): unknown {
    const obj: any = {};
    if (message.filepath !== "") {
      obj.filepath = message.filepath;
    }
    if (message.oldString !== "") {
      obj.oldString = message.oldString;
    }
    if (message.newString !== "") {
      obj.newString = message.newString;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EditFile>, I>>(base?: I): EditFile {
    return EditFile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EditFile>, I>>(object: I): EditFile {
    const message = createBaseEditFile();
    message.filepath = object.filepath ?? "";
    message.oldString = object.oldString ?? "";
    message.newString = object.newString ?? "";
    return message;
  },
};

function createBaseRunHTTPRequest(): RunHTTPRequest {
  return { method: "", path: "", body: undefined };
}

export const RunHTTPRequest: MessageFns<RunHTTPRequest> = {
  encode(message: RunHTTPRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.method !== "") {
      writer.uint32(10).string(message.method);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.body !== undefined) {
      writer.uint32(26).string(message.body);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunHTTPRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunHTTPRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.method = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.body = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunHTTPRequest {
    return {
      method: isSet(object.method) ? globalThis.String(object.method) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      body: isSet(object.body) ? globalThis.String(object.body) : undefined,
    };
  },

  toJSON(message: RunHTTPRequest): unknown {
    const obj: any = {};
    if (message.method !== "") {
      obj.method = message.method;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.body !== undefined) {
      obj.body = message.body;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunHTTPRequest>, I>>(base?: I): RunHTTPRequest {
    return RunHTTPRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunHTTPRequest>, I>>(object: I): RunHTTPRequest {
    const message = createBaseRunHTTPRequest();
    message.method = object.method ?? "";
    message.path = object.path ?? "";
    message.body = object.body ?? undefined;
    return message;
  },
};

function createBaseRunGitCommand(): RunGitCommand {
  return { command: "", arguments: undefined, repositoryUrl: "" };
}

export const RunGitCommand: MessageFns<RunGitCommand> = {
  encode(message: RunGitCommand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.command !== "") {
      writer.uint32(10).string(message.command);
    }
    if (message.arguments !== undefined) {
      writer.uint32(18).string(message.arguments);
    }
    if (message.repositoryUrl !== "") {
      writer.uint32(26).string(message.repositoryUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunGitCommand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunGitCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.command = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.arguments = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.repositoryUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunGitCommand {
    return {
      command: isSet(object.command) ? globalThis.String(object.command) : "",
      arguments: isSet(object.arguments) ? globalThis.String(object.arguments) : undefined,
      repositoryUrl: isSet(object.repositoryUrl) ? globalThis.String(object.repositoryUrl) : "",
    };
  },

  toJSON(message: RunGitCommand): unknown {
    const obj: any = {};
    if (message.command !== "") {
      obj.command = message.command;
    }
    if (message.arguments !== undefined) {
      obj.arguments = message.arguments;
    }
    if (message.repositoryUrl !== "") {
      obj.repositoryUrl = message.repositoryUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunGitCommand>, I>>(base?: I): RunGitCommand {
    return RunGitCommand.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunGitCommand>, I>>(object: I): RunGitCommand {
    const message = createBaseRunGitCommand();
    message.command = object.command ?? "";
    message.arguments = object.arguments ?? undefined;
    message.repositoryUrl = object.repositoryUrl ?? "";
    return message;
  },
};

function createBaseGenerateTokenRequest(): GenerateTokenRequest {
  return { workflowDefinition: undefined };
}

export const GenerateTokenRequest: MessageFns<GenerateTokenRequest> = {
  encode(message: GenerateTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workflowDefinition !== undefined) {
      writer.uint32(10).string(message.workflowDefinition);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workflowDefinition = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateTokenRequest {
    return {
      workflowDefinition: isSet(object.workflowDefinition) ? globalThis.String(object.workflowDefinition) : undefined,
    };
  },

  toJSON(message: GenerateTokenRequest): unknown {
    const obj: any = {};
    if (message.workflowDefinition !== undefined) {
      obj.workflowDefinition = message.workflowDefinition;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateTokenRequest>, I>>(base?: I): GenerateTokenRequest {
    return GenerateTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateTokenRequest>, I>>(object: I): GenerateTokenRequest {
    const message = createBaseGenerateTokenRequest();
    message.workflowDefinition = object.workflowDefinition ?? undefined;
    return message;
  },
};

function createBaseGenerateTokenResponse(): GenerateTokenResponse {
  return { token: "", expiresAt: 0 };
}

export const GenerateTokenResponse: MessageFns<GenerateTokenResponse> = {
  encode(message: GenerateTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    if (message.expiresAt !== 0) {
      writer.uint32(16).int64(message.expiresAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.expiresAt = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateTokenResponse {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      expiresAt: isSet(object.expiresAt) ? globalThis.Number(object.expiresAt) : 0,
    };
  },

  toJSON(message: GenerateTokenResponse): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.expiresAt !== 0) {
      obj.expiresAt = Math.round(message.expiresAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateTokenResponse>, I>>(base?: I): GenerateTokenResponse {
    return GenerateTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateTokenResponse>, I>>(object: I): GenerateTokenResponse {
    const message = createBaseGenerateTokenResponse();
    message.token = object.token ?? "";
    message.expiresAt = object.expiresAt ?? 0;
    return message;
  },
};

function createBaseListToolsRequest(): ListToolsRequest {
  return {};
}

export const ListToolsRequest: MessageFns<ListToolsRequest> = {
  encode(_: ListToolsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListToolsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListToolsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListToolsRequest {
    return {};
  },

  toJSON(_: ListToolsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ListToolsRequest>, I>>(base?: I): ListToolsRequest {
    return ListToolsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListToolsRequest>, I>>(_: I): ListToolsRequest {
    const message = createBaseListToolsRequest();
    return message;
  },
};

function createBaseListToolsResponse(): ListToolsResponse {
  return { tools: [], evalDataset: [] };
}

export const ListToolsResponse: MessageFns<ListToolsResponse> = {
  encode(message: ListToolsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tools) {
      Struct.encode(Struct.wrap(v!), writer.uint32(10).fork()).join();
    }
    for (const v of message.evalDataset) {
      Struct.encode(Struct.wrap(v!), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListToolsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListToolsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tools.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.evalDataset.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListToolsResponse {
    return {
      tools: globalThis.Array.isArray(object?.tools) ? [...object.tools] : [],
      evalDataset: globalThis.Array.isArray(object?.evalDataset) ? [...object.evalDataset] : [],
    };
  },

  toJSON(message: ListToolsResponse): unknown {
    const obj: any = {};
    if (message.tools?.length) {
      obj.tools = message.tools;
    }
    if (message.evalDataset?.length) {
      obj.evalDataset = message.evalDataset;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListToolsResponse>, I>>(base?: I): ListToolsResponse {
    return ListToolsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListToolsResponse>, I>>(object: I): ListToolsResponse {
    const message = createBaseListToolsResponse();
    message.tools = object.tools?.map((e) => e) || [];
    message.evalDataset = object.evalDataset?.map((e) => e) || [];
    return message;
  },
};

function createBaseListFlowsRequest(): ListFlowsRequest {
  return { filters: undefined };
}

export const ListFlowsRequest: MessageFns<ListFlowsRequest> = {
  encode(message: ListFlowsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filters !== undefined) {
      ListFlowsRequestFilter.encode(message.filters, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFlowsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFlowsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filters = ListFlowsRequestFilter.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFlowsRequest {
    return { filters: isSet(object.filters) ? ListFlowsRequestFilter.fromJSON(object.filters) : undefined };
  },

  toJSON(message: ListFlowsRequest): unknown {
    const obj: any = {};
    if (message.filters !== undefined) {
      obj.filters = ListFlowsRequestFilter.toJSON(message.filters);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListFlowsRequest>, I>>(base?: I): ListFlowsRequest {
    return ListFlowsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListFlowsRequest>, I>>(object: I): ListFlowsRequest {
    const message = createBaseListFlowsRequest();
    message.filters = (object.filters !== undefined && object.filters !== null)
      ? ListFlowsRequestFilter.fromPartial(object.filters)
      : undefined;
    return message;
  },
};

function createBaseListFlowsRequestFilter(): ListFlowsRequestFilter {
  return { flowIdentifier: [], environment: [], version: [] };
}

export const ListFlowsRequestFilter: MessageFns<ListFlowsRequestFilter> = {
  encode(message: ListFlowsRequestFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.flowIdentifier) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.environment) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.version) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFlowsRequestFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFlowsRequestFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.flowIdentifier.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.environment.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.version.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFlowsRequestFilter {
    return {
      flowIdentifier: globalThis.Array.isArray(object?.flowIdentifier)
        ? object.flowIdentifier.map((e: any) => globalThis.String(e))
        : [],
      environment: globalThis.Array.isArray(object?.environment)
        ? object.environment.map((e: any) => globalThis.String(e))
        : [],
      version: globalThis.Array.isArray(object?.version) ? object.version.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ListFlowsRequestFilter): unknown {
    const obj: any = {};
    if (message.flowIdentifier?.length) {
      obj.flowIdentifier = message.flowIdentifier;
    }
    if (message.environment?.length) {
      obj.environment = message.environment;
    }
    if (message.version?.length) {
      obj.version = message.version;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListFlowsRequestFilter>, I>>(base?: I): ListFlowsRequestFilter {
    return ListFlowsRequestFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListFlowsRequestFilter>, I>>(object: I): ListFlowsRequestFilter {
    const message = createBaseListFlowsRequestFilter();
    message.flowIdentifier = object.flowIdentifier?.map((e) => e) || [];
    message.environment = object.environment?.map((e) => e) || [];
    message.version = object.version?.map((e) => e) || [];
    return message;
  },
};

function createBaseListFlowsResponse(): ListFlowsResponse {
  return { configs: [] };
}

export const ListFlowsResponse: MessageFns<ListFlowsResponse> = {
  encode(message: ListFlowsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.configs) {
      Struct.encode(Struct.wrap(v!), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFlowsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFlowsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.configs.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFlowsResponse {
    return { configs: globalThis.Array.isArray(object?.configs) ? [...object.configs] : [] };
  },

  toJSON(message: ListFlowsResponse): unknown {
    const obj: any = {};
    if (message.configs?.length) {
      obj.configs = message.configs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListFlowsResponse>, I>>(base?: I): ListFlowsResponse {
    return ListFlowsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListFlowsResponse>, I>>(object: I): ListFlowsResponse {
    const message = createBaseListFlowsResponse();
    message.configs = object.configs?.map((e) => e) || [];
    return message;
  },
};

function createBaseNewCheckpoint(): NewCheckpoint {
  return { status: "", checkpoint: "", goal: "", errors: [] };
}

export const NewCheckpoint: MessageFns<NewCheckpoint> = {
  encode(message: NewCheckpoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    if (message.checkpoint !== "") {
      writer.uint32(18).string(message.checkpoint);
    }
    if (message.goal !== "") {
      writer.uint32(26).string(message.goal);
    }
    for (const v of message.errors) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NewCheckpoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNewCheckpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.checkpoint = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.goal = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.errors.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NewCheckpoint {
    return {
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      checkpoint: isSet(object.checkpoint) ? globalThis.String(object.checkpoint) : "",
      goal: isSet(object.goal) ? globalThis.String(object.goal) : "",
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: NewCheckpoint): unknown {
    const obj: any = {};
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.checkpoint !== "") {
      obj.checkpoint = message.checkpoint;
    }
    if (message.goal !== "") {
      obj.goal = message.goal;
    }
    if (message.errors?.length) {
      obj.errors = message.errors;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NewCheckpoint>, I>>(base?: I): NewCheckpoint {
    return NewCheckpoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NewCheckpoint>, I>>(object: I): NewCheckpoint {
    const message = createBaseNewCheckpoint();
    message.status = object.status ?? "";
    message.checkpoint = object.checkpoint ?? "";
    message.goal = object.goal ?? "";
    message.errors = object.errors?.map((e) => e) || [];
    return message;
  },
};

function createBaseListDirectory(): ListDirectory {
  return { directory: "" };
}

export const ListDirectory: MessageFns<ListDirectory> = {
  encode(message: ListDirectory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.directory !== "") {
      writer.uint32(10).string(message.directory);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDirectory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDirectory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.directory = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDirectory {
    return { directory: isSet(object.directory) ? globalThis.String(object.directory) : "" };
  },

  toJSON(message: ListDirectory): unknown {
    const obj: any = {};
    if (message.directory !== "") {
      obj.directory = message.directory;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListDirectory>, I>>(base?: I): ListDirectory {
    return ListDirectory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListDirectory>, I>>(object: I): ListDirectory {
    const message = createBaseListDirectory();
    message.directory = object.directory ?? "";
    return message;
  },
};

function createBaseGrep(): Grep {
  return { searchDirectory: "", pattern: "", caseInsensitive: false };
}

export const Grep: MessageFns<Grep> = {
  encode(message: Grep, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.searchDirectory !== "") {
      writer.uint32(10).string(message.searchDirectory);
    }
    if (message.pattern !== "") {
      writer.uint32(18).string(message.pattern);
    }
    if (message.caseInsensitive !== false) {
      writer.uint32(24).bool(message.caseInsensitive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Grep {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.searchDirectory = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pattern = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.caseInsensitive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Grep {
    return {
      searchDirectory: isSet(object.searchDirectory) ? globalThis.String(object.searchDirectory) : "",
      pattern: isSet(object.pattern) ? globalThis.String(object.pattern) : "",
      caseInsensitive: isSet(object.caseInsensitive) ? globalThis.Boolean(object.caseInsensitive) : false,
    };
  },

  toJSON(message: Grep): unknown {
    const obj: any = {};
    if (message.searchDirectory !== "") {
      obj.searchDirectory = message.searchDirectory;
    }
    if (message.pattern !== "") {
      obj.pattern = message.pattern;
    }
    if (message.caseInsensitive !== false) {
      obj.caseInsensitive = message.caseInsensitive;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Grep>, I>>(base?: I): Grep {
    return Grep.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Grep>, I>>(object: I): Grep {
    const message = createBaseGrep();
    message.searchDirectory = object.searchDirectory ?? "";
    message.pattern = object.pattern ?? "";
    message.caseInsensitive = object.caseInsensitive ?? false;
    return message;
  },
};

function createBaseFindFiles(): FindFiles {
  return { namePattern: "" };
}

export const FindFiles: MessageFns<FindFiles> = {
  encode(message: FindFiles, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.namePattern !== "") {
      writer.uint32(10).string(message.namePattern);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FindFiles {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFindFiles();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.namePattern = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FindFiles {
    return { namePattern: isSet(object.namePattern) ? globalThis.String(object.namePattern) : "" };
  },

  toJSON(message: FindFiles): unknown {
    const obj: any = {};
    if (message.namePattern !== "") {
      obj.namePattern = message.namePattern;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FindFiles>, I>>(base?: I): FindFiles {
    return FindFiles.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FindFiles>, I>>(object: I): FindFiles {
    const message = createBaseFindFiles();
    message.namePattern = object.namePattern ?? "";
    return message;
  },
};

function createBaseMcpTool(): McpTool {
  return { name: "", description: "", inputSchema: "" };
}

export const McpTool: MessageFns<McpTool> = {
  encode(message: McpTool, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.inputSchema !== "") {
      writer.uint32(26).string(message.inputSchema);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): McpTool {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMcpTool();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inputSchema = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): McpTool {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      inputSchema: isSet(object.inputSchema) ? globalThis.String(object.inputSchema) : "",
    };
  },

  toJSON(message: McpTool): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.inputSchema !== "") {
      obj.inputSchema = message.inputSchema;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<McpTool>, I>>(base?: I): McpTool {
    return McpTool.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<McpTool>, I>>(object: I): McpTool {
    const message = createBaseMcpTool();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.inputSchema = object.inputSchema ?? "";
    return message;
  },
};

function createBaseRunMCPTool(): RunMCPTool {
  return { name: "", args: "" };
}

export const RunMCPTool: MessageFns<RunMCPTool> = {
  encode(message: RunMCPTool, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.args !== "") {
      writer.uint32(18).string(message.args);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunMCPTool {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunMCPTool();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.args = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunMCPTool {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      args: isSet(object.args) ? globalThis.String(object.args) : "",
    };
  },

  toJSON(message: RunMCPTool): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.args !== "") {
      obj.args = message.args;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunMCPTool>, I>>(base?: I): RunMCPTool {
    return RunMCPTool.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunMCPTool>, I>>(object: I): RunMCPTool {
    const message = createBaseRunMCPTool();
    message.name = object.name ?? "";
    message.args = object.args ?? "";
    return message;
  },
};

function createBaseAdditionalContext(): AdditionalContext {
  return { category: "", id: undefined, content: undefined, metadata: undefined };
}

export const AdditionalContext: MessageFns<AdditionalContext> = {
  encode(message: AdditionalContext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.category !== "") {
      writer.uint32(10).string(message.category);
    }
    if (message.id !== undefined) {
      writer.uint32(18).string(message.id);
    }
    if (message.content !== undefined) {
      writer.uint32(26).string(message.content);
    }
    if (message.metadata !== undefined) {
      writer.uint32(34).string(message.metadata);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdditionalContext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdditionalContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdditionalContext {
    return {
      category: isSet(object.category) ? globalThis.String(object.category) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : undefined,
      content: isSet(object.content) ? globalThis.String(object.content) : undefined,
      metadata: isSet(object.metadata) ? globalThis.String(object.metadata) : undefined,
    };
  },

  toJSON(message: AdditionalContext): unknown {
    const obj: any = {};
    if (message.category !== "") {
      obj.category = message.category;
    }
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    if (message.content !== undefined) {
      obj.content = message.content;
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AdditionalContext>, I>>(base?: I): AdditionalContext {
    return AdditionalContext.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AdditionalContext>, I>>(object: I): AdditionalContext {
    const message = createBaseAdditionalContext();
    message.category = object.category ?? "";
    message.id = object.id ?? undefined;
    message.content = object.content ?? undefined;
    message.metadata = object.metadata ?? undefined;
    return message;
  },
};

function createBaseApproval(): Approval {
  return { approval: undefined, rejection: undefined };
}

export const Approval: MessageFns<Approval> = {
  encode(message: Approval, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.approval !== undefined) {
      Approval_Approved.encode(message.approval, writer.uint32(10).fork()).join();
    }
    if (message.rejection !== undefined) {
      Approval_Rejected.encode(message.rejection, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Approval {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApproval();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.approval = Approval_Approved.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rejection = Approval_Rejected.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Approval {
    return {
      approval: isSet(object.approval) ? Approval_Approved.fromJSON(object.approval) : undefined,
      rejection: isSet(object.rejection) ? Approval_Rejected.fromJSON(object.rejection) : undefined,
    };
  },

  toJSON(message: Approval): unknown {
    const obj: any = {};
    if (message.approval !== undefined) {
      obj.approval = Approval_Approved.toJSON(message.approval);
    }
    if (message.rejection !== undefined) {
      obj.rejection = Approval_Rejected.toJSON(message.rejection);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Approval>, I>>(base?: I): Approval {
    return Approval.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Approval>, I>>(object: I): Approval {
    const message = createBaseApproval();
    message.approval = (object.approval !== undefined && object.approval !== null)
      ? Approval_Approved.fromPartial(object.approval)
      : undefined;
    message.rejection = (object.rejection !== undefined && object.rejection !== null)
      ? Approval_Rejected.fromPartial(object.rejection)
      : undefined;
    return message;
  },
};

function createBaseApproval_Approved(): Approval_Approved {
  return {};
}

export const Approval_Approved: MessageFns<Approval_Approved> = {
  encode(_: Approval_Approved, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Approval_Approved {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApproval_Approved();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Approval_Approved {
    return {};
  },

  toJSON(_: Approval_Approved): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Approval_Approved>, I>>(base?: I): Approval_Approved {
    return Approval_Approved.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Approval_Approved>, I>>(_: I): Approval_Approved {
    const message = createBaseApproval_Approved();
    return message;
  },
};

function createBaseApproval_Rejected(): Approval_Rejected {
  return { message: undefined };
}

export const Approval_Rejected: MessageFns<Approval_Rejected> = {
  encode(message: Approval_Rejected, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Approval_Rejected {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApproval_Rejected();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Approval_Rejected {
    return { message: isSet(object.message) ? globalThis.String(object.message) : undefined };
  },

  toJSON(message: Approval_Rejected): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Approval_Rejected>, I>>(base?: I): Approval_Rejected {
    return Approval_Rejected.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Approval_Rejected>, I>>(object: I): Approval_Rejected {
    const message = createBaseApproval_Rejected();
    message.message = object.message ?? undefined;
    return message;
  },
};

function createBaseMkdir(): Mkdir {
  return { directoryPath: "" };
}

export const Mkdir: MessageFns<Mkdir> = {
  encode(message: Mkdir, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.directoryPath !== "") {
      writer.uint32(10).string(message.directoryPath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Mkdir {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMkdir();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.directoryPath = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Mkdir {
    return { directoryPath: isSet(object.directoryPath) ? globalThis.String(object.directoryPath) : "" };
  },

  toJSON(message: Mkdir): unknown {
    const obj: any = {};
    if (message.directoryPath !== "") {
      obj.directoryPath = message.directoryPath;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Mkdir>, I>>(base?: I): Mkdir {
    return Mkdir.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Mkdir>, I>>(object: I): Mkdir {
    const message = createBaseMkdir();
    message.directoryPath = object.directoryPath ?? "";
    return message;
  },
};

function createBaseOsInformationContext(): OsInformationContext {
  return { platform: "", architecture: "" };
}

export const OsInformationContext: MessageFns<OsInformationContext> = {
  encode(message: OsInformationContext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.platform !== "") {
      writer.uint32(10).string(message.platform);
    }
    if (message.architecture !== "") {
      writer.uint32(18).string(message.architecture);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OsInformationContext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOsInformationContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.platform = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.architecture = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OsInformationContext {
    return {
      platform: isSet(object.platform) ? globalThis.String(object.platform) : "",
      architecture: isSet(object.architecture) ? globalThis.String(object.architecture) : "",
    };
  },

  toJSON(message: OsInformationContext): unknown {
    const obj: any = {};
    if (message.platform !== "") {
      obj.platform = message.platform;
    }
    if (message.architecture !== "") {
      obj.architecture = message.architecture;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OsInformationContext>, I>>(base?: I): OsInformationContext {
    return OsInformationContext.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OsInformationContext>, I>>(object: I): OsInformationContext {
    const message = createBaseOsInformationContext();
    message.platform = object.platform ?? "";
    message.architecture = object.architecture ?? "";
    return message;
  },
};

function createBaseShellInformationContext(): ShellInformationContext {
  return {
    shellName: "",
    shellType: "",
    shellVariant: undefined,
    shellEnvironment: undefined,
    sshSession: undefined,
    cwd: undefined,
  };
}

export const ShellInformationContext: MessageFns<ShellInformationContext> = {
  encode(message: ShellInformationContext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shellName !== "") {
      writer.uint32(10).string(message.shellName);
    }
    if (message.shellType !== "") {
      writer.uint32(18).string(message.shellType);
    }
    if (message.shellVariant !== undefined) {
      writer.uint32(26).string(message.shellVariant);
    }
    if (message.shellEnvironment !== undefined) {
      writer.uint32(34).string(message.shellEnvironment);
    }
    if (message.sshSession !== undefined) {
      writer.uint32(40).bool(message.sshSession);
    }
    if (message.cwd !== undefined) {
      writer.uint32(50).string(message.cwd);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShellInformationContext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShellInformationContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.shellName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.shellType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.shellVariant = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.shellEnvironment = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.sshSession = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.cwd = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShellInformationContext {
    return {
      shellName: isSet(object.shellName) ? globalThis.String(object.shellName) : "",
      shellType: isSet(object.shellType) ? globalThis.String(object.shellType) : "",
      shellVariant: isSet(object.shellVariant) ? globalThis.String(object.shellVariant) : undefined,
      shellEnvironment: isSet(object.shellEnvironment) ? globalThis.String(object.shellEnvironment) : undefined,
      sshSession: isSet(object.sshSession) ? globalThis.Boolean(object.sshSession) : undefined,
      cwd: isSet(object.cwd) ? globalThis.String(object.cwd) : undefined,
    };
  },

  toJSON(message: ShellInformationContext): unknown {
    const obj: any = {};
    if (message.shellName !== "") {
      obj.shellName = message.shellName;
    }
    if (message.shellType !== "") {
      obj.shellType = message.shellType;
    }
    if (message.shellVariant !== undefined) {
      obj.shellVariant = message.shellVariant;
    }
    if (message.shellEnvironment !== undefined) {
      obj.shellEnvironment = message.shellEnvironment;
    }
    if (message.sshSession !== undefined) {
      obj.sshSession = message.sshSession;
    }
    if (message.cwd !== undefined) {
      obj.cwd = message.cwd;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShellInformationContext>, I>>(base?: I): ShellInformationContext {
    return ShellInformationContext.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShellInformationContext>, I>>(object: I): ShellInformationContext {
    const message = createBaseShellInformationContext();
    message.shellName = object.shellName ?? "";
    message.shellType = object.shellType ?? "";
    message.shellVariant = object.shellVariant ?? undefined;
    message.shellEnvironment = object.shellEnvironment ?? undefined;
    message.sshSession = object.sshSession ?? undefined;
    message.cwd = object.cwd ?? undefined;
    return message;
  },
};

export type NeoaiWorkflowService = typeof NeoaiWorkflowService;
export const NeoaiWorkflowService = {
  executeWorkflow: {
    path: "/NeoaiWorkflow/ExecuteWorkflow",
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: ClientEvent): Buffer => Buffer.from(ClientEvent.encode(value).finish()),
    requestDeserialize: (value: Buffer): ClientEvent => ClientEvent.decode(value),
    responseSerialize: (value: Action): Buffer => Buffer.from(Action.encode(value).finish()),
    responseDeserialize: (value: Buffer): Action => Action.decode(value),
  },
  generateToken: {
    path: "/NeoaiWorkflow/GenerateToken",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GenerateTokenRequest): Buffer => Buffer.from(GenerateTokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GenerateTokenRequest => GenerateTokenRequest.decode(value),
    responseSerialize: (value: GenerateTokenResponse): Buffer =>
      Buffer.from(GenerateTokenResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GenerateTokenResponse => GenerateTokenResponse.decode(value),
  },
  listTools: {
    path: "/NeoaiWorkflow/ListTools",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListToolsRequest): Buffer => Buffer.from(ListToolsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListToolsRequest => ListToolsRequest.decode(value),
    responseSerialize: (value: ListToolsResponse): Buffer => Buffer.from(ListToolsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListToolsResponse => ListToolsResponse.decode(value),
  },
  listFlows: {
    path: "/NeoaiWorkflow/ListFlows",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListFlowsRequest): Buffer => Buffer.from(ListFlowsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListFlowsRequest => ListFlowsRequest.decode(value),
    responseSerialize: (value: ListFlowsResponse): Buffer => Buffer.from(ListFlowsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListFlowsResponse => ListFlowsResponse.decode(value),
  },
} as const;

export interface NeoaiWorkflowServer extends UntypedServiceImplementation {
  executeWorkflow: handleBidiStreamingCall<ClientEvent, Action>;
  generateToken: handleUnaryCall<GenerateTokenRequest, GenerateTokenResponse>;
  listTools: handleUnaryCall<ListToolsRequest, ListToolsResponse>;
  listFlows: handleUnaryCall<ListFlowsRequest, ListFlowsResponse>;
}

export interface NeoaiWorkflowClient extends Client {
  executeWorkflow(): ClientDuplexStream<ClientEvent, Action>;
  executeWorkflow(options: Partial<CallOptions>): ClientDuplexStream<ClientEvent, Action>;
  executeWorkflow(metadata: Metadata, options?: Partial<CallOptions>): ClientDuplexStream<ClientEvent, Action>;
  generateToken(
    request: GenerateTokenRequest,
    callback: (error: ServiceError | null, response: GenerateTokenResponse) => void,
  ): ClientUnaryCall;
  generateToken(
    request: GenerateTokenRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GenerateTokenResponse) => void,
  ): ClientUnaryCall;
  generateToken(
    request: GenerateTokenRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GenerateTokenResponse) => void,
  ): ClientUnaryCall;
  listTools(
    request: ListToolsRequest,
    callback: (error: ServiceError | null, response: ListToolsResponse) => void,
  ): ClientUnaryCall;
  listTools(
    request: ListToolsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListToolsResponse) => void,
  ): ClientUnaryCall;
  listTools(
    request: ListToolsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListToolsResponse) => void,
  ): ClientUnaryCall;
  listFlows(
    request: ListFlowsRequest,
    callback: (error: ServiceError | null, response: ListFlowsResponse) => void,
  ): ClientUnaryCall;
  listFlows(
    request: ListFlowsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListFlowsResponse) => void,
  ): ClientUnaryCall;
  listFlows(
    request: ListFlowsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListFlowsResponse) => void,
  ): ClientUnaryCall;
}

export const NeoaiWorkflowClient = makeGenericClientConstructor(NeoaiWorkflowService, "NeoaiWorkflow") as unknown as {
  new(address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): NeoaiWorkflowClient;
  service: typeof NeoaiWorkflowService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
